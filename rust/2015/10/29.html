<!DOCTYPE html>
<!-- this is removed if there is javascript loading. -->
<html class="no-js">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Rust Lifetimes</title>
  <meta name="description" content="Lifetimes are pretty much what makes Rust Rust.">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://www.charlesetc.com/rust/2015/10/29">
  <link rel="alternate" type="application/rss+xml" title="Charles etc" href="http://www.charlesetc.com/feed.xml" />
  
</head>


  <body class="  ">

    
<header class="site-header site-header-transition ">

  <div class="wrapper">

    <a class="site-title" href="/#back">Charles etc</a>


</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <p class="post-meta">Oct 29, 2015</p>
    <h1 class="post-title">Rust Lifetimes</h1>
  </header>

  <article class="post-content">
    <p>Lifetimes are pretty much what makes Rust Rust.</p>

<p>Easy concurrency, straightforward memory allocation, 
and overall data safety would not be possible without explicit lifetimes.</p>

<p>But they are also tricky, and this is aimed at helping people understand the concepts and syntax.</p>

<h1 id="what-are-lifetimes">What are Lifetimes?</h1>

<p>Rust is a unique language in that it deallocates memory on the heap without requiring the writer to call <code class="highlighter-rouge">free</code>, 
while at the same time having no need for a garbage collector.
Rust knows when it’s okay to use a reference by keeping track of its lifetime.</p>

<p>Each time a reference is returned by or passed into a function, Rust checks at compile time to make sure it fulfills the lifetime requirement specified in the type signature.</p>

<p>So every reference in Rust (i.e. pointer) has a lifetime. A lifetime is part of the type signature for any reference. Sometimes they can be elided 
and the compiler can infer them. Nonetheless, you cannot program Rust without knowing how to specify lifetimes.</p>

<p>Lifetimes fulfill two roles for Rust:</p>

<ol>
  <li>
    <p>To know when it’s safe to dereference a pointer</p>
  </li>
  <li>
    <p>To allow data to be shared safely</p>
  </li>
</ol>

<p>Now, <strong>you are not in charge of defining lifetimes.</strong></p>

<p>Sometimes, however, you will have to give names to existing lifetimes in order to change the default behavior of the compiler.</p>

<h1 id="where-do-lifetimes-come-from">Where do Lifetimes come from?</h1>

<p>Lifetimes are always named with the same syntax. 
They look like <code class="highlighter-rouge">&lt;'a&gt;</code>, <code class="highlighter-rouge">&lt;'b&gt;</code>, or <code class="highlighter-rouge">&lt;'c&gt;</code>, 
and they are generally one letter prefaced 
by an apostrophe.</p>

<p>When you use one, though, there is more syntax involved. 
Depending on the context they can look like one of: <code class="highlighter-rouge">something&lt;'a&gt;</code>, <code class="highlighter-rouge">Box&lt;something + 'a&gt;</code> or <code class="highlighter-rouge">&amp;'a something</code></p>

<p>Note well: You will only ever write a lifetime within a type declaration.</p>

<p>So if you don’t define lifetimes, what does?</p>

<h1 id="functions">Functions</h1>

<p>This is a biggie. A function can define a lifetime that can be used in it’s type declarations.</p>

<p>This makes sense: If you want to take a reference to something on the function stack, you have to be prepared for it to disappear when the function is over. And if not, you need to make sure it has an appropriate lifetime.</p>

<p>In Go, you can do this:</p>

<div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">example_function</span><span class="p">()</span><span class="x"> </span><span class="o">*</span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="n">b</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">3</span><span class="x">
  </span><span class="k">return</span><span class="x"> </span><span class="o">&amp;</span><span class="n">b</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">*</span><span class="n">example_function</span><span class="p">());</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre>
</div>

<p>However, you cannot do that in Rust:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="n">example_function</span><span class="o">&lt;</span><span class="err">'</span><span class="n">a</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="err">'</span><span class="n">a</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="o">&amp;</span><span class="n">b</span> <span class="c">// this does not compile</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">example_function</span><span class="p">());</span> 
<span class="p">}</span>
</code></pre>
</div>

<p>The reason is that <code class="highlighter-rouge">&amp;b</code> does not live long enough to be dereferenced outside of the function that made it.</p>

<p>Why is this so important? Because this is what can happen in C:</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span><span class="o">*</span> <span class="nf">example_function</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">do_something</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// lies, don't do anything
</span><span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="n">example_function</span><span class="p">();</span>
  <span class="n">do_something</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>In C this is Undefined Behavior. When I run this, it just prints “3”.</p>

<p>That’s right, the data can just change under your nose. I was honestly scared when I ran that. But Rust prevents crazy things like that from taking place!</p>

<p>So just to explicitly point out the syntax:</p>

<p><code class="highlighter-rouge">example_function&lt;'a&gt;</code> is saying “for any lifetime called <code class="highlighter-rouge">'a</code>…”. You can then go on to use this lifetime in the remainder of the type definition.</p>

<p><code class="highlighter-rouge">&amp;'a i32</code> says “This is a reference to an integer that has lifetime <code class="highlighter-rouge">'a</code>”, 
which means it has to last as long as “any lifetime”. However, <code class="highlighter-rouge">b</code> happens to only have a lifetime that lasts as long as the function’s scope, so Rust complains.</p>

<p>(Now at this point you might be asking how you actually would return a reference to <code class="highlighter-rouge">3</code> in Rust… 
that’s a more complicated question and the answer is to put it on the heap. Look up the <code class="highlighter-rouge">Box</code> type to learn more.)</p>

<p>And now on to bigger fish.</p>

<h1 id="structs">Structs</h1>

<p>Structs also define lifetimes.</p>

<p>Think about it like this:</p>

<p>If a struct includes a reference to something, then that reference damn sure better last as long as the struct.</p>

<p>Here’s how you can make sure of that:</p>

<h2 id="wrong-example">Wrong example:</h2>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Sheep</span> <span class="p">{</span>
  <span class="n">age</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">i32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Sheep</span> <span class="p">{</span> <span class="n">age</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">a</span> <span class="p">};</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{};"</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>

<p>This gives the following error:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="ss">error: </span><span class="n">missing</span> <span class="n">lifetime</span> <span class="n">specifier</span> <span class="p">[</span><span class="no">E0106</span><span class="p">]</span>
        <span class="ss">age: </span><span class="o">&amp;</span><span class="n">i32</span><span class="p">,</span>
             <span class="o">^~~~</span> 
</code></pre>
</div>

<p>Rust is mad. 
In the struct definition, you haven’t told it how long the reference to the <code class="highlighter-rouge">i32</code> is allowed to stay around.
And yet, in order for your code to be safe, it has to stick around for at least as long as the struct.</p>

<h2 id="right-example">Right Example</h2>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Sheep</span><span class="o">&lt;</span><span class="err">'</span><span class="n">c</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">age</span><span class="p">:</span> <span class="o">&amp;</span><span class="err">'</span><span class="n">c</span> <span class="nb">i32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Sheep</span> <span class="p">{</span> <span class="n">age</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">a</span> <span class="p">};</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{};"</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>

<p>You’ll notice that not much here has changed. But now Rust has pronounced your code safe — Hurray!</p>

<p>Here are the changes:</p>

<ol>
  <li><code class="highlighter-rouge">Sheep&lt;'c&gt;</code> instead of <code class="highlighter-rouge">Sheep</code></li>
</ol>

<p>This is making a parameter for the struct in Rust — It’s lifetime might have to depend on the lifetimes of its fields, so now you are able to say how and which ones. (Note: you can do things like <code class="highlighter-rouge">Sheep&lt;'c, 'd&gt;</code> if you need more than one lifetime.)</p>

<ol>
  <li>
    <p><code class="highlighter-rouge">age: &amp;'c i32</code> instead of <code class="highlighter-rouge">age: &amp;i32</code></p>

    <p>Now this says that the integer has to live for as long as the struct.</p>
  </li>
</ol>

<p>This is <strong>insanely</strong> impressive. 
With these small additions, Rust will now tell you if there is any chance of you having invalid data,
even across threads. AND all of this happens at compile time without affecting the efficiency of your code.</p>

<h1 id="implementations">Implementations</h1>

<p>There is one other place where a lifetime can be defined — Implementations.</p>

<p>It’s very similar to structs. Each implementation is an implementation of a certain
trait for a struct. So if the struct requires an explicit lifetime, you need to have one to give it.</p>

<h2 id="wrong-example-1">Wrong Example</h2>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Sheep</span><span class="o">&lt;</span><span class="err">'</span><span class="n">c</span><span class="o">&gt;</span> <span class="p">{</span>                                                             
  <span class="n">age</span><span class="p">:</span> <span class="o">&amp;</span><span class="err">'</span><span class="n">c</span> <span class="k">mut</span> <span class="nb">i32</span><span class="p">,</span>
<span class="p">}</span>                                                                              
                                                                               
<span class="k">impl</span> <span class="n">Sheep</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">grow_old</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span>  <span class="p">{</span>
        <span class="o">*</span><span class="k">self</span><span class="py">.age</span> <span class="o">+=</span> <span class="mi">100</span>
    <span class="p">}</span>                    
<span class="p">}</span>                   
</code></pre>
</div>

<p>This fails with the following:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="ss">error: </span><span class="n">wrong</span> <span class="n">number</span> <span class="n">of</span> <span class="n">lifetime</span> <span class="ss">parameters: </span><span class="n">expected</span> <span class="mi">1</span><span class="p">,</span> <span class="n">found</span> <span class="mi">0</span> <span class="p">[</span><span class="no">E0107</span><span class="p">]</span>
        <span class="n">impl</span> <span class="no">Sheep</span> <span class="p">{</span>
             <span class="o">^~~~~</span>
</code></pre>
</div>

<h2 id="right-example-1">Right Example</h2>

<p>What’s the problem?</p>

<p><code class="highlighter-rouge">Sheep</code> takes a lifetime parameter now, so one must be supplied:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Sheep</span><span class="o">&lt;</span><span class="err">'</span><span class="n">c</span><span class="o">&gt;</span> <span class="p">{</span>                                                             
  <span class="n">age</span><span class="p">:</span> <span class="o">&amp;</span><span class="err">'</span><span class="n">c</span> <span class="k">mut</span> <span class="nb">i32</span><span class="p">,</span>
<span class="p">}</span>                                                                              
                                                                               
<span class="k">impl</span><span class="o">&lt;</span><span class="err">'</span><span class="n">c</span><span class="o">&gt;</span> <span class="n">Sheep</span><span class="o">&lt;</span><span class="err">'</span><span class="n">c</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">grow_old</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span>  <span class="p">{</span>
        <span class="o">*</span><span class="k">self</span><span class="py">.age</span> <span class="o">+=</span> <span class="mi">100</span>
    <span class="p">}</span>                    
<span class="p">}</span>
</code></pre>
</div>

<p>Note that <code class="highlighter-rouge">impl&lt;'c&gt;</code> names a new lifetime and <code class="highlighter-rouge">Sheep&lt;'c&gt;</code> says that all 
<code class="highlighter-rouge">self</code>’s in this implementation have at least the lifetime <code class="highlighter-rouge">'c</code>.</p>

<p>This is a lot like an extenuation of the lifetimes with structs, but there 
is strange syntax with the <code class="highlighter-rouge">impl&lt;'c&gt; Sheep&lt;'c&gt;</code> so I wanted to point it out.</p>

<h1 id="the-end">The End</h1>

<p>And that is all I know about lifetimes in Rust!</p>

<p>If you’re interested, here is a <a href="/rust/2015/10/31">concise reference</a> for the syntax used with lifetimes.</p>


  </article>

</div>

      </div>
    </div>

    <!-- <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Charles etc</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Charles etc</li>
          <li><a href="mailto:charlespipin@gmail.com">charlespipin@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/charlesetc">
              <span class="icon  icongithub">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">charlesetc</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/charlesetc">
              <span class="icon  icontwitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">charlesetc</span>
            </a>
          </li>
          
        </ul>
      </div>


      <div class="footer-col  footer-col-3">
        <p class="text"></p>
      </div>
    </div>

  </div>

  </footer> -->


    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-69527650-1', 'auto');
      ga('send', 'pageview');
    </script>

  </body>
</html>
