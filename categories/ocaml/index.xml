<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ocaml on Charles, etc</title>
    <link>http://www.charlesetc.com/categories/ocaml/</link>
    <description>Recent content in Ocaml on Charles, etc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 22 Jun 2016 02:00:42 -0400</lastBuildDate>
    
	<atom:link href="http://www.charlesetc.com/categories/ocaml/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Exceptions in Reason (OCaml)</title>
      <link>http://www.charlesetc.com/exceptions-in-ocaml/</link>
      <pubDate>Wed, 22 Jun 2016 02:00:42 -0400</pubDate>
      
      <guid>http://www.charlesetc.com/exceptions-in-ocaml/</guid>
      <description>Pattern Matching A large part of function programming is pattern matching:
/* A new and delicious enum */type fruit=Apple|Pear|Pineapple|Orange;letmy_fruit=Pear;/* print the outcome of the switch statement */print_string(switchmy_fruit{|Apple=&amp;gt;&amp;#34;you have an apple&amp;#34;|Pear=&amp;gt;&amp;#34;you have a pear&amp;#34;|_=&amp;gt;&amp;#34;you have neither an apple or a pear&amp;#34;}); Except&amp;hellip; The cool part is how Reason handles exceptions: as another branch in a switch statement.
exceptionMy_exception;/* * Here&amp;#39;s a function that occasionally throws an exception */letrisky_function=&amp;gt;switch(Random.int3){|0=&amp;gt;true|1=&amp;gt;false|2=&amp;gt;raiseMy_exception};/* * We can match against the possible cases of risky_function, * even exceptions.</description>
    </item>
    
  </channel>
</rss>